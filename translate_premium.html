<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Translation App</title>
    <style>
        @font-face {
            font-family: 'Cousine';
            src: url('fonts/Cousine-Bold.ttf') format('truetype');
        }
        
        :root {
            --primary-color: #2498Eb;
            --secondary-color: #2c3e50;
            --background-color: #ffffff;
            --text-color: #333;
            --border-radius: 4px;
            --cc-background: #000000;
            --cc-text-color: #ffffff;
            --cc-font-size: 24px;
            --cc-line-height: 1.2;
        }

        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            margin: 0;
            padding: 20px;
        }

        h2 {
            color: var(--secondary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        a:hover {
            color: var(--secondary-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }

        .language-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .output {
            font-family: Cousine, monospace;
            margin-top: 15px;
            color: black;
            min-height: 120px;
            font-size: 2.5em;
            line-height: 1.1em;
            letter-spacing: 0.0em;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: var(--border-radius);
            background-color: #f9f9f9;
        }

        .output span { 
            background-color: black; 
            padding: 8px 8px 0px 8px;
            margin: 0;
            color: white;
        }

        select, input[type="checkbox"], input[type="text"] {
            margin: 5px 0;
            padding: 8px;
            border-radius: var(--border-radius);
            border: 1px solid #ddd;
        }

        input[type="text"] {
            width: 300px;
        }

        label {
            display: inline-flex;
            align-items: center;
            margin-right: 15px;
            gap: 5px;
        }

        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            height: 70px;
            resize: vertical;
            margin-bottom: 15px;
        }
        
        #status {
            margin-top: 10px;
            font-style: italic;
            color: var(--secondary-color);
        }

        .api-key-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .api-key-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: var(--border-radius);
            font-weight: bold;
        }

        .status-inactive {
            background-color: #ffeeba;
            color: #856404;
        }

        .status-active {
            background-color: #d4edda;
            color: #155724;
        }

        .button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .button:hover {
            background-color: var(--secondary-color);
        }

        .button.paused {
            background-color: #dc3545;
        }

        .error-message {
            color: #dc3545;
            font-weight: bold;
            margin: 10px 0;
        }

        .hidden {
            display: none;
        }

        .overlay-link {
            margin: 15px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: var(--border-radius);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .control-panel {
                flex-direction: column;
                align-items: flex-start;
            }
            
            input[type="text"] {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Real-time Translation App - Premium Version</h2>
        
        <p>This app uses speech recognition to transcribe your voice and translate it in real-time. It uses Google Cloud API, which has a broader selection of languages vs free alternatives.</p>
        
        <div class="api-key-container">
            <label for="apiKey">Google Translation API Key:</label>
            <input type="text" id="apiKey" placeholder="Enter your API key here">
            <button id="saveApiKey" class="button">Save Key</button>
            <span id="apiKeyStatus" class="api-key-status status-inactive">No API Key</span>
        </div>
        
        <div class="overlay-link">
            Overlay URL (for OBS): <a id="shareLink" href="#" target="_blank">Loading...</a>
            <button id="copyLink" class="button">Copy Link</button>
        </div>
        
        <div class="control-panel">
            <div class="language-selector">
                <label for="langFrom">From:</label>
                <select id="langFrom"></select>
            </div>
            
            <div class="language-selector">
                <label for="langTo">To:</label>
                <select id="langTo"></select>
            </div>
            
            <label>
                <input type="checkbox" id="fullContext">
                Include previous context
            </label>
            
            <label>
                <input type="checkbox" id="enabledTranscription">
                Enable translation
            </label>
            
            <label>
                <input type="checkbox" id="incrementalUpdates">
                Incremental updates
            </label>
            
            <button id="toggleTranscription" class="button">Pause Transcription</button>
        </div>
        
        <div id="errorContainer" class="error-message hidden"></div>
        <div id="status"></div>
        
        <textarea id="input" placeholder="Transcribed text will appear here..."></textarea>
        
        <div id="output" class="output">Translated text will appear here...</div>
    </div>

    <script>
        // Main app functionality
        const app = {
            // App state
            state: {
                apiKey: '',
                roomId: '',
                myLang: navigator.language || 'en-US',
                targetLang: 'en',
                isPaused: false,
                isTranscribing: false,
                languageData: [],
                lastTranscription: '',
                secondTranscription: '',
                finalTranscript: '',
                counter: 0,
                activeRequest: null,
                lastRequestTime: 0,
                languageMap: {}
            },
            
            // DOM Elements
            elements: {
                apiKeyInput: document.getElementById('apiKey'),
                apiKeyStatus: document.getElementById('apiKeyStatus'),
                saveApiKeyBtn: document.getElementById('saveApiKey'),
                langFromSelect: document.getElementById('langFrom'),
                langToSelect: document.getElementById('langTo'),
                fullContextCheckbox: document.getElementById('fullContext'),
                enabledTranscriptionCheckbox: document.getElementById('enabledTranscription'),
                incrementalUpdatesCheckbox: document.getElementById('incrementalUpdates'),
                toggleTranscriptionBtn: document.getElementById('toggleTranscription'),
                inputTextarea: document.getElementById('input'),
                outputDiv: document.getElementById('output'),
                statusDiv: document.getElementById('status'),
                shareLink: document.getElementById('shareLink'),
                copyLinkBtn: document.getElementById('copyLink'),
                errorContainer: document.getElementById('errorContainer')
            },
            
            // Speech recognition object
            recognition: null,
            
            // WebSocket connection
            socket: null,
            retryCount: 0,
            
            // Initialize the application
            init: function() {
                this.loadApiKey();
                this.generateRoomId();
                this.loadLanguagePreferences();
                this.setupEventListeners();
                this.fetchLanguages();
                this.connectWebSocket();
                this.updateShareLink();
            },
            
            // Load API Key from storage if available
            loadApiKey: function() {
                const savedKey = this.getStorage('apiKey');
                if (savedKey) {
                    this.state.apiKey = savedKey;
                    this.elements.apiKeyInput.value = savedKey;
                    this.updateApiKeyStatus(true);
                } else {
                    this.updateApiKeyStatus(false);
                }
            },
            
            // Update API Key status display
            updateApiKeyStatus: function(isActive) {
                if (isActive) {
                    this.elements.apiKeyStatus.textContent = 'API Key Active';
                    this.elements.apiKeyStatus.className = 'api-key-status status-active';
                } else {
                    this.elements.apiKeyStatus.textContent = 'No API Key';
                    this.elements.apiKeyStatus.className = 'api-key-status status-inactive';
                }
            },
            
            // Generate a unique room ID for websocket communication
            generateRoomId: function() {
                const urlParams = new URLSearchParams(window.location.search);
                
                if (urlParams.has('room')) {
                    this.state.roomId = urlParams.get('room');
                } else {
                    this.state.roomId = this.generateRandomId();
                    this.updateURL('room=' + this.state.roomId);
                }
            },
            
            // Create a random ID for the room
            generateRandomId: function() {
                const possible = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789";
                let text = "";
                for (let i = 0; i < 7; i++) {
                    text += possible.charAt(Math.floor(Math.random() * possible.length));
                }
                return text;
            },
            
            // Load previously saved language preferences
            loadLanguagePreferences: function() {
                const urlParams = new URLSearchParams(window.location.search);
                
                // Source language
                if (urlParams.has('lang')) {
                    this.state.myLang = urlParams.get('lang');
                } else if (this.getStorage('myLang')) {
                    this.state.myLang = this.getStorage('myLang');
                } else {
                    this.updateURL('lang=' + this.state.myLang);
                }
                
                this.state.myLangCode = this.state.myLang.split('-')[0].toLowerCase();
                
                // Target language
                if (urlParams.has('translate') || urlParams.has('target')) {
                    this.state.targetLang = urlParams.get('translate') || urlParams.get('target');
                } else if (this.getStorage('targetLang')) {
                    this.state.targetLang = this.getStorage('targetLang');
                } else {
                    // Default target language
                    this.state.targetLang = this.state.myLangCode === 'en' ? 'de' : 'en';
                    this.updateURL('translate=' + this.state.targetLang);
                }
                
                this.setStorage('targetLang', this.state.targetLang, 999999);
                this.setStorage('myLang', this.state.myLang, 999999);
            },
            
            // Set up all event listeners
            setupEventListeners: function() {
                // API Key button
                this.elements.saveApiKeyBtn.addEventListener('click', () => {
                    const newKey = this.elements.apiKeyInput.value.trim();
                    if (newKey) {
                        this.state.apiKey = newKey;
                        this.setStorage('apiKey', newKey, 999999);
                        this.updateApiKeyStatus(true);
                        this.fetchLanguages(); // Refresh languages with new key
                    } else {
                        this.showError('Please enter a valid API key');
                    }
                });
                
                // Copy link button
                this.elements.copyLinkBtn.addEventListener('click', () => {
                    navigator.clipboard.writeText(this.elements.shareLink.href)
                        .then(() => {
                            this.elements.copyLinkBtn.textContent = 'Copied!';
                            setTimeout(() => {
                                this.elements.copyLinkBtn.textContent = 'Copy Link';
                            }, 2000);
                        })
                        .catch(err => {
                            this.showError('Failed to copy: ' + err);
                        });
                });
                
                // Language selectors
                this.elements.langFromSelect.addEventListener('change', (e) => {
                    const newLang = e.target.value;
                    this.state.myLang = newLang;
                    this.state.myLangCode = newLang.split('-')[0].toLowerCase();
                    
                    // Ensure source and target are different
                    if (this.state.myLangCode === this.state.targetLang) {
                        this.state.targetLang = (this.state.myLangCode === 'en') ? 'de' : 'en';
                        this.updateLanguageSelectors();
                    }
                    
                    this.updateURL('lang=' + this.state.myLang, true);
                    this.setStorage('myLang', this.state.myLang, 999999);
                    
                    // Restart recognition with new language
                    this.restartRecognition();
                });
                
                this.elements.langToSelect.addEventListener('change', (e) => {
                    const newTarget = e.target.value;
                    
                    // Ensure source and target are different
                    if (newTarget === this.state.myLangCode) {
                        this.showError('Source and target languages cannot be the same');
                        // Reset to previous or alternative
                        this.updateLanguageSelectors();
                        return;
                    }
                    
                    this.state.targetLang = newTarget;
                    this.updateURL('translate=' + this.state.targetLang, true);
                    this.setStorage('targetLang', this.state.targetLang, 999999);
                    
                    // Translate current input with new target language
                    const currentText = this.elements.inputTextarea.value.trim();
                    if (currentText && this.elements.enabledTranscriptionCheckbox.checked) {
                        this.translateText(currentText);
                    }
                });
                
                // Toggle transcription button
                this.elements.toggleTranscriptionBtn.addEventListener('click', () => {
                    this.state.isPaused = !this.state.isPaused;
                    
                    if (this.state.isPaused) {
                        if (this.recognition) {
                            this.recognition.stop();
                        }
                        this.elements.toggleTranscriptionBtn.textContent = 'Resume Transcription';
                        this.elements.toggleTranscriptionBtn.classList.add('paused');
                    } else {
                        this.restartRecognition();
                        this.elements.toggleTranscriptionBtn.textContent = 'Pause Transcription';
                        this.elements.toggleTranscriptionBtn.classList.remove('paused');
                    }
                });
                
                // Checkbox handlers
                this.elements.incrementalUpdatesCheckbox.addEventListener('change', () => {
                    this.restartRecognition();
                });
            },
            
            // Connect to WebSocket server
            connectWebSocket: function() {
                if (this.socket) {
                    this.socket.close();
                    this.socket = null;
                }

                this.socket = new WebSocket("wss://api.caption.ninja:443");

                this.socket.onclose = () => {
                    console.log("WebSocket connection closed. Attempting to reconnect...");
                    const delay = this.getRetryDelay();
                    console.log(`Reconnecting in ${delay}ms (attempt ${this.retryCount + 1})...`);
                    setTimeout(() => this.connectWebSocket(), delay);
                    this.retryCount++;
                };

                this.socket.onopen = () => {
                    console.log("WebSocket connected. Joining room...");
                    this.retryCount = 0;
                    this.socket.send(JSON.stringify({"join": this.state.roomId}));
                };

                this.socket.onerror = (error) => {
                    console.error("WebSocket error:", error);
                    if (this.socket) {
                        this.socket.close();
                        this.socket = null;
                    }
                };
            },
            
            // Calculate delay for reconnection attempts
            getRetryDelay: function() {
                if (this.retryCount === 0) {
                    return 0; // First retry is immediate
                }
                // Exponential backoff: 1000ms * 2^(retryCount-1), capped at 30 seconds
                return Math.min(1000 * Math.pow(2, this.retryCount - 1), 30000);
            },
            
            // Fetch available languages from Google API
            fetchLanguages: function() {
                let url;
                
                if (this.state.apiKey) {
                    url = `https://www.googleapis.com/language/translate/v2/languages?key=${this.state.apiKey}`;
                } else {
                    // Fallback to a public proxy if no API key is available
                    url = `https://captionninjapremium.vdo.workers.dev/?ts=${Date.now()}`;
                }
                
                fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error.message || 'Error fetching languages');
                    }
                    
                    this.processLanguages(data.data.languages);
                })
                .catch(error => {
                    this.showError('Failed to fetch languages: ' + error.message);
                    console.error('Language fetch error:', error);
                    
                    // Load some default languages if API fails
                    this.loadDefaultLanguages();
                });
            },
            
            // Process fetched languages and populate selectors
            processLanguages: function(languages) {
                this.state.languageData = languages;
                
                // Create language map
                languages.forEach(lang => {
                    const langName = this.getLanguageName(lang.language);
                    this.state.languageMap[lang.language] = langName;
                });
                
                // Populate language selectors
                this.populateLanguageSelectors();
                
                // Initialize speech recognition
                this.setupSpeechRecognition();
            },
            
            // Get readable language name from code
            getLanguageName: function(code) {
                // Language name mapping
                const languageNames = {
                    "aa": "Afar", "ab": "Abkhazian", "ae": "Avestan", "af": "Afrikaans",
                    "ak": "Akan", "am": "Amharic", "an": "Aragonese", "ar": "Arabic",
                    "as": "Assamese", "av": "Avaric", "ay": "Aymara", "az": "Azerbaijani",
                    "ba": "Bashkir", "be": "Belarusian", "bg": "Bulgarian", "bh": "Bihari",
                    "bi": "Bislama", "bm": "Bambara", "bn": "Bengali", "bo": "Tibetan",
                    "br": "Breton", "bs": "Bosnian", "ca": "Catalan", "ce": "Chechen",
                    "ch": "Chamorro", "co": "Corsican", "cr": "Cree", "cs": "Czech",
                    "cu": "Church Slavic", "cv": "Chuvash", "cy": "Welsh", "da": "Danish",
                    "de": "German", "dv": "Divehi", "dz": "Dzongkha", "ee": "Ewe",
                    "el": "Greek", "en": "English", "eo": "Esperanto", "es": "Spanish",
                    "et": "Estonian", "eu": "Basque", "fa": "Persian", "ff": "Fulah",
                    "fi": "Finnish", "fj": "Fijian", "fo": "Faroese", "fr": "French",
                    "fy": "Western Frisian", "ga": "Irish", "gd": "Scottish Gaelic",
                    "gl": "Galician", "gn": "Guarani", "gu": "Gujarati", "gv": "Manx",
                    "ha": "Hausa", "he": "Hebrew", "hi": "Hindi", "ho": "Hiri Motu",
                    "hr": "Croatian", "ht": "Haitian", "hu": "Hungarian", "hy": "Armenian",
                    "hz": "Herero", "ia": "Interlingua", "id": "Indonesian", "ie": "Interlingue",
                    "ig": "Igbo", "ii": "Sichuan Yi", "ik": "Inupiaq", "io": "Ido",
                    "is": "Icelandic", "it": "Italian", "iu": "Inuktitut", "ja": "Japanese",
                    "jv": "Javanese", "ka": "Georgian", "kg": "Kongo", "ki": "Kikuyu",
                    "kj": "Kuanyama", "kk": "Kazakh", "kl": "Kalaallisut", "km": "Khmer",
                    "kn": "Kannada", "ko": "Korean", "kr": "Kanuri", "ks": "Kashmiri",
                    "ku": "Kurdish", "kv": "Komi", "kw": "Cornish", "ky": "Kyrgyz",
                    "la": "Latin", "lb": "Luxembourgish", "lg": "Ganda", "li": "Limburgan",
                    "ln": "Lingala", "lo": "Lao", "lt": "Lithuanian", "lu": "Luba-Katanga",
                    "lv": "Latvian", "mg": "Malagasy", "mh": "Marshallese", "mi": "Maori",
                    "mk": "Macedonian", "ml": "Malayalam", "mn": "Mongolian", "mr": "Marathi",
                    "ms": "Malay", "mt": "Maltese", "my": "Burmese", "na": "Nauru",
                    "nb": "Norwegian Bokmål", "nd": "North Ndebele", "ne": "Nepali",
                    "ng": "Ndonga", "nl": "Dutch", "nn": "Norwegian Nynorsk", "no": "Norwegian",
                    "nr": "South Ndebele", "nv": "Navajo", "ny": "Chichewa", "oc": "Occitan",
                    "oj": "Ojibwa", "om": "Oromo", "or": "Oriya", "os": "Ossetian",
                    "pa": "Punjabi", "pi": "Pali", "pl": "Polish", "ps": "Pashto",
                    "pt": "Portuguese", "qu": "Quechua", "rm": "Romansh", "rn": "Rundi",
                    "ro": "Romanian", "ru": "Russian", "rw": "Kinyarwanda", "sa": "Sanskrit",
                    "sc": "Sardinian", "sd": "Sindhi", "se": "Northern Sami", "sg": "Sango",
                    "si": "Sinhala", "sk": "Slovak", "sl": "Slovenian", "sm": "Samoan",
                    "sn": "Shona", "so": "Somali", "sq": "Albanian", "sr": "Serbian",
                    "ss": "Swati", "st": "Southern Sotho", "su": "Sundanese", "sv": "Swedish",
                    "sw": "Swahili", "ta": "Tamil", "te": "Telugu", "tg": "Tajik",
                    "th": "Thai", "ti": "Tigrinya", "tk": "Turkmen", "tl": "Tagalog",
                    "tn": "Tswana", "to": "Tonga", "tr": "Turkish", "ts": "Tsonga",
                    "tt": "Tatar", "tw": "Twi", "ty": "Tahitian", "ug": "Uighur",
                    "uk": "Ukrainian", "ur": "Urdu", "uz": "Uzbek", "ve": "Venda",
                    "vi": "Vietnamese", "vo": "Volapük", "wa": "Walloon", "wo": "Wolof",
                    "xh": "Xhosa", "yi": "Yiddish", "yo": "Yoruba", "za": "Zhuang",
                    "zh": "Chinese", "zu": "Zulu"
                };
                
                return languageNames[code] || code;
            },
            
            // Load default languages if API fails
            loadDefaultLanguages: function() {
                const defaultLanguages = [
                    { language: "en" }, { language: "de" }, { language: "fr" }, 
                    { language: "es" }, { language: "it" }, { language: "nl" },
                    { language: "pt" }, { language: "ru" }, { language: "zh" }, 
                    { language: "ja" }, { language: "ko" }, { language: "ar" }
                ];
                this.processLanguages(defaultLanguages);
            },
            
            // Populate the language dropdown selectors
            populateLanguageSelectors: function() {
                // Clear existing options
                this.elements.langFromSelect.innerHTML = '';
                this.elements.langToSelect.innerHTML = '';
                
                // Add options to source language selector
                this.state.languageData.forEach(lang => {
                    const option = document.createElement('option');
                    const langName = this.getLanguageName(lang.language);
                    option.value = lang.language;
                    option.textContent = langName;
                    
                    if (lang.language === this.state.myLangCode) {
                        option.selected = true;
                    }
                    
                    this.elements.langFromSelect.appendChild(option);
                });
                
                // Add options to target language selector
                this.state.languageData.forEach(lang => {
                    const option = document.createElement('option');
                    const langName = this.getLanguageName(lang.language);
                    option.value = lang.language;
                    option.textContent = langName;
                    
                    if (lang.language === this.state.targetLang) {
                        option.selected = true;
                    }
                    
                    this.elements.langToSelect.appendChild(option);
                });
                
                // Make sure source and target aren't the same
                this.updateLanguageSelectors();
            },
            
            // Ensure source and target languages are different
            updateLanguageSelectors: function() {
                // If source and target are the same, change target
                if (this.state.myLangCode === this.state.targetLang) {
                    this.state.targetLang = (this.state.myLangCode === 'en') ? 'de' : 'en';
                }
                
                // Update selectors to reflect current state
                const fromOptions = this.elements.langFromSelect.options;
                for (let i = 0; i < fromOptions.length; i++) {
                    if (fromOptions[i].value === this.state.myLangCode) {
                        fromOptions[i].selected = true;
                        break;
                    }
                }
                
                const toOptions = this.elements.langToSelect.options;
                for (let i = 0; i < toOptions.length; i++) {
                    if (toOptions[i].value === this.state.targetLang) {
                        toOptions[i].selected = true;
                        break;
                    }
                }
            },
            
            // Update the overlay share link
            updateShareLink: function() {
                const baseUrl = window.location.href.split('?')[0];
                const overlayUrl = baseUrl.replace(/\/[^\/]*$/, '/overlay') + 
                                  `?room=${this.state.roomId}`;
                
                this.elements.shareLink.href = overlayUrl;
                this.elements.shareLink.textContent = overlayUrl;
            },
            
            // Set up speech recognition
            setupSpeechRecognition: function() {
                if (!('webkitSpeechRecognition' in window)) {
                    this.showError('Speech recognition is not supported in your browser. Try Chrome or Edge.');
                    return;
                }
                
                // Create new recognition instance
                this.recognition = new webkitSpeechRecognition();
                
                // Configure recognition
                this.recognition.lang = this.state.myLang;
                this.recognition.continuous = true;
                this.recognition.interimResults = this.elements.incrementalUpdatesCheckbox.checked;
                
                // Set up event handlers
                this.recognition.onstart = () => {
                    console.log("Speech recognition started");
                    this.elements.statusDiv.textContent = "Listening...";
                    this.state.isTranscribing = true;
                };
                
                this.recognition.onerror = (event) => {
                    console.error("Recognition error:", event);
                    
                    if (event.error === 'no-speech') {
                        this.elements.statusDiv.textContent = "No speech detected. Still listening...";
                    } else if (event.error === 'audio-capture') {
                        this.showError("No microphone detected");
} else if (event.error === 'not-allowed') {
                        this.showError("Microphone access denied. Please allow microphone access in your browser settings.");
                    } else if (event.error === 'aborted') {
                        console.log("Recognition aborted");
                    } else {
                        this.showError(`Speech recognition error: ${event.error}`);
                    }
                };
                
                this.recognition.onend = () => {
                    console.log("Speech recognition ended");
                    
                    // Process any remaining text if needed
                    this.processRemainingText();
                    
                    if (!this.state.isPaused && this.state.isTranscribing) {
                        console.log("Restarting recognition...");
                        this.elements.statusDiv.textContent = "Reconnecting...";
                        
                        // Restart with a slight delay
                        setTimeout(() => {
                            try {
                                this.recognition.start();
                            } catch (err) {
                                console.error("Error restarting recognition:", err);
                                // If restart fails, create a new instance
                                this.setupSpeechRecognition();
                            }
                        }, 300);
                    } else {
                        this.elements.statusDiv.textContent = "Paused";
                    }
                };
                
                this.recognition.onresult = (event) => {
                    if (typeof(event.results) === 'undefined') {
                        console.log('Undefined results in event:', event);
                        return;
                    }
                    
                    // Process the speech recognition results
                    this.processSpeechResults(event);
                };
                
                // Start recognition if not paused
                if (!this.state.isPaused) {
                    try {
                        this.recognition.start();
                    } catch (error) {
                        console.error("Error starting recognition:", error);
                        this.showError("Failed to start speech recognition");
                    }
                }
            },
            
            // Process speech recognition results
            processSpeechResults: function(event) {
                let currentBatchFinal = '';
                let currentBatchInterim = '';
                
                // Process all results in the current batch
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = this.sanitizeText(event.results[i][0].transcript);
                    
                    if (event.results[i].isFinal) {
                        currentBatchFinal += (currentBatchFinal ? ' ' : '') + transcript;
                        console.log(`Processing text: ${transcript} Final: true`);
                    } else {
                        currentBatchInterim += (currentBatchInterim ? ' ' : '') + transcript;
                        console.log(`Processing text: ${transcript} Final: false`);
                    }
                }
                
                // Update transcript based on results
                if (currentBatchFinal) {
                    // Add final segments to the final transcript
                    this.state.finalTranscript += (this.state.finalTranscript ? ' ' : '') + currentBatchFinal;
                    
                    // Update input display
                    this.elements.inputTextarea.value = this.state.finalTranscript;
                    
                    // Translate the final text
                    this.translateText(this.state.finalTranscript);
                    
                    // Update context for future translations
                    this.state.secondTranscription = this.state.lastTranscription;
                    this.state.lastTranscription = this.state.finalTranscript.trim().replace(/\.?$/, '.') + ' ';
                    this.state.finalTranscript = '';
                    
                    console.log("Updated context state:", {
                        second: this.state.secondTranscription,
                        last: this.state.lastTranscription
                    });
                } 
                else if (currentBatchInterim && this.elements.incrementalUpdatesCheckbox.checked) {
                    // Display combined text for UI
                    const displayText = this.state.finalTranscript + 
                                       (this.state.finalTranscript ? ' ' : '') + 
                                       currentBatchInterim;
                    
                    this.elements.inputTextarea.value = displayText;
                    
                    // Only translate interim results if enabled and not overloaded
                    if (this.state.activeRequest === null && 
                        (Date.now() - this.state.lastRequestTime > 250)) {
                        this.translateText(displayText, true);
                    }
                }
            },
            
            // Process any remaining text when recognition ends
            processRemainingText: function() {
                const currentText = this.elements.inputTextarea.value.trim();
                
                if (currentText && 
                    this.elements.enabledTranscriptionCheckbox.checked && 
                    currentText !== this.state.lastTranscription.trim()) {
                    
                    console.log("Processing final text from interrupted recognition:", currentText);
                    this.translateText(currentText);
                    
                    // Update context tracking
                    this.state.secondTranscription = this.state.lastTranscription;
                    this.state.lastTranscription = currentText.replace(/\.?$/, '.') + ' ';
                    this.state.finalTranscript = '';
                }
            },
            
            // Translate text using Google Translate API
            translateText: function(textToTranslate, isInterim = false) {
                if (!textToTranslate?.trim() || !this.elements.enabledTranscriptionCheckbox.checked) {
                    return;
                }
                
                // Make sure source and target are different
                if (this.state.myLangCode === this.state.targetLang) {
                    console.warn("Source and target languages are the same:", this.state.myLangCode);
                    this.state.targetLang = (this.state.myLangCode === 'en') ? 'de' : 'en';
                    this.updateLanguageSelectors();
                }
                
                // Add context if enabled
                let contextText = textToTranslate;
                if (this.elements.fullContextCheckbox.checked) {
                    let fullText = [];
                    if (this.state.secondTranscription?.trim()) {
                        fullText.push(this.state.secondTranscription.trim().replace(/\.?$/, '.'));
                    }
                    if (this.state.lastTranscription?.trim()) {
                        fullText.push(this.state.lastTranscription.trim().replace(/\.?$/, '.'));
                    }
                    if (textToTranslate?.trim()) {
                        fullText.push(textToTranslate.trim());
                    }
                    
                    contextText = fullText.join(' ');
                    console.log("Translating with context:", contextText);
                }
                
                // Check for rate limiting
                const now = Date.now();
                const timeSinceLastRequest = now - this.state.lastRequestTime;
                if (timeSinceLastRequest < 250) {
                    console.log("Rate limiting in effect, skipping request");
                    return;
                }
                
                this.state.lastRequestTime = now;
                
                // Cancel any active request
                if (this.state.activeRequest) {
                    this.state.activeRequest.abort();
                    this.state.activeRequest = null;
                }
                
                // Build API URL
                const url = this.state.apiKey
                    ? `https://www.googleapis.com/language/translate/v2/?key=${this.state.apiKey}&q=${encodeURIComponent(contextText)}&target=${this.state.targetLang}&source=${this.state.myLangCode}`
                    : `https://captionninjapremium.vdo.workers.dev/?ts=${Date.now()}&q=${encodeURIComponent(contextText)}&target=${this.state.targetLang}&source=${this.state.myLangCode}`;
                
                // Check cache first
                const cachedTranslation = this.getCachedTranslation(url);
                if (cachedTranslation) {
                    console.log('Using cached translation');
                    this.updateTranslation(cachedTranslation, isInterim);
                    return;
                }
                
                // Create fetch request with timeout
                const controller = new AbortController();
                this.state.activeRequest = controller;
                
                const timeoutId = setTimeout(() => {
                    if (this.state.activeRequest === controller) {
                        console.log('Request timeout');
                        controller.abort();
                        this.state.activeRequest = null;
                    }
                }, 3000);
                
                fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    signal: controller.signal
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data?.data?.translations?.[0]) {
                        throw new Error('Invalid response format from translation service');
                    }
                    
                    const translatedText = data.data.translations[0].translatedText;
                    
                    // Cache the translation
                    this.cacheTranslation(url, data.data);
                    
                    // Update UI with translation
                    this.updateTranslation(translatedText, isInterim);
                })
                .catch(error => {
                    if (error.name === 'AbortError') {
                        console.log('Request was aborted');
                        return;
                    }
                    
                    console.error('Translation error:', error);
                    
                    // Handle rate limiting
                    if (error.message.includes('HTTP error! status: 429')) {
                        if (this.elements.incrementalUpdatesCheckbox.checked) {
                            this.elements.incrementalUpdatesCheckbox.checked = false;
                            this.showError('Incremental updates have been disabled due to rate limiting');
                            this.restartRecognition();
                        }
                    }
                    
                    // Show error to user (but not too frequently)
                    const now = Date.now();
                    if (!window.lastErrorTime || (now - window.lastErrorTime) > 5000) {
                        window.lastErrorTime = now;
                        this.handleTranslationError(error);
                    }
                })
                .finally(() => {
                    clearTimeout(timeoutId);
                    if (this.state.activeRequest === controller) {
                        this.state.activeRequest = null;
                    }
                });
            },
            
            // Update UI with translation and send to WebSocket
            updateTranslation: function(translatedText, isInterim) {
                // Store for backup
                window.lastSuccessfulTranslation = translatedText;
                
                // Update UI
                this.elements.outputDiv.innerHTML = this.formatTranslatedText(translatedText);
                
                // Increment message counter
                this.state.counter += 1;
                
                // Send to WebSocket for overlay
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({
                        "msg": true,
                        [isInterim ? "interm" : "final"]: translatedText,
                        "id": this.state.counter,
                        "c": this.elements.fullContextCheckbox.checked,
                        "ln": this.state.targetLang
                    }));
                }
            },
            
            // Format translated text with spans for better readability
            formatTranslatedText: function(text) {
                // Split text by sentences or periods
                const segments = text.split(/(?<=\.)\s+/);
                
                if (segments.length <= 1) {
                    return `<span>${text}</span>`;
                }
                
                // Format with spans for each segment
                return segments.map(segment => {
                    if (segment.trim()) {
                        return `<span>${segment}</span>`;
                    }
                    return '';
                }).join(' ');
            },
            
            // Handle translation errors
            handleTranslationError: function(error) {
                let errorMessage = '';
                
                if (error instanceof TypeError && error.message.includes('CORS')) {
                    errorMessage = 'CORS Error: Unable to access the translation service. Check your API key.';
                } else if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    errorMessage = 'Network Error: Unable to connect to the translation service.';
                } else if (error.message.includes('HTTP error! status: 403')) {
                    errorMessage = 'Authorization Error: Invalid API key or insufficient permissions.';
                } else if (error.message.includes('HTTP error! status: 429')) {
                    errorMessage = 'Rate Limit Error: Too many requests. Try disabling incremental updates.';
                } else if (error.message.includes('HTTP error! status: 400')) {
                    errorMessage = 'Bad Request: Source and target languages may be the same.';
                } else if (error.message.includes('Invalid response format')) {
                    errorMessage = 'Error: Unexpected response from the translation service.';
                } else {
                    errorMessage = `Translation Error: ${error.message}`;
                }
                
                this.showError(errorMessage);
            },
            
            // Restart speech recognition
            restartRecognition: function() {
                if (this.recognition) {
                    this.recognition.onend = null; // Prevent auto-restart
                    this.recognition.stop();
                    
                    setTimeout(() => {
                        this.recognition = null;
                        this.setupSpeechRecognition();
                    }, 300);
                } else {
                    this.setupSpeechRecognition();
                }
            },
            
            // Show error message to user
            showError: function(message) {
                this.elements.errorContainer.textContent = message;
                this.elements.errorContainer.classList.remove('hidden');
                
                setTimeout(() => {
                    this.elements.errorContainer.classList.add('hidden');
                }, 5000);
            },
            
            // Sanitize text input
            sanitizeText: function(string) {
                const temp = document.createElement('div');
                temp.textContent = string;
                return temp.textContent
                    .substring(0, Math.min(temp.textContent.length, 500))
                    .trim();
            },
            
            // Get cached translation
            getCachedTranslation: function(url) {
                try {
                    const cached = localStorage.getItem('translation_' + url);
                    if (cached) {
                        const { data, timestamp } = JSON.parse(cached);
                        // Cache valid for 24 hours
                        if (Date.now() - timestamp < 24 * 60 * 60 * 1000) {
                            return data?.translations?.[0]?.translatedText || null;
                        }
                        localStorage.removeItem('translation_' + url);
                    }
                } catch (e) {
                    console.error('Cache error:', e);
                }
                return null;
            },
            
            // Cache translation results
            cacheTranslation: function(url, data) {
                try {
                    localStorage.setItem('translation_' + url, JSON.stringify({
                        data: data,
                        timestamp: Date.now()
                    }));
                } catch (e) {
                    console.error('Cache storage error:', e);
                    // Clean up old cache entries if storage is full
                    try {
                        const keys = Object.keys(localStorage);
                        for (let key of keys) {
                            if (key.startsWith('translation_')) {
                                localStorage.removeItem(key);
                            }
                        }
                    } catch (e) {
                        console.error('Cache cleanup error:', e);
                    }
                }
            },
            
            // Local storage utility functions
            getStorage: function(key) {
                try {
                    const itemStr = localStorage.getItem(key);
                    if (!itemStr) {
                        return null;
                    }
                    
                    const item = JSON.parse(itemStr);
                    const now = new Date();
                    
                    if (now.getTime() > item.expiry) {
                        localStorage.removeItem(key);
                        return null;
                    }
                    
                    return item.value;
                } catch (e) {
                    console.error('Storage error:', e);
                    return null;
                }
            },
            
            setStorage: function(key, value, hours = 24) {
                try {
                    const now = new Date();
                    const item = {
                        value: value,
                        expiry: now.getTime() + (hours * 60 * 60 * 1000)
                    };
                    
                    localStorage.setItem(key, JSON.stringify(item));
                } catch (e) {
                    console.error('Storage save error:', e);
                }
            },
            
            // Update URL with new parameters
            updateURL: function(param, replace = false) {
                const urlParams = new URLSearchParams(window.location.search);
                const paramParts = param.split('=');
                const paramName = paramParts[0];
                const paramValue = paramParts.length > 1 ? paramParts[1] : '';
                
                if (replace || !urlParams.has(paramName)) {
                    urlParams.set(paramName, paramValue);
                    
                    const newUrl = window.location.pathname + '?' + urlParams.toString();
                    window.history.pushState({ path: newUrl }, '', newUrl);
                }
            }
        };

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            app.init();
        });
    </script>
</body>
</html>						
